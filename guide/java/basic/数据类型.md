---
title: 数据类型
icon: java
category:
  - Java
tag:
  - Java基础知识
  - 数据类型
---

## 基本数据类型
Java中的基本数据类型信息如下表所示：

| 基本类型 | 位数 | 字节 | 默认值 | 取值范围                               |
| -------- | ---- | ---- | ------- | ------------------------------------------ |
| byte     | 8    | 1    | 0       | -128 ~ 127                                 |
| short    | 16   | 2    | 0       | -32768 ~ 32767                             |
| int      | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| long     | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| char     | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| float    | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| double   | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| boolean  | 1    |      | false   | true、false                               |

### 基本数据类型和对应包装类型的差别
Java中每个基本数据类型都有对应的包装类型，而Java自带了**自动装箱**和**自动拆箱**机制方便基本类型和包装类型之间的相互转换。基本数据类型和对应包装类型主要有以下差别：
1. 基本数据类型实例的身份和值是一个东西；包装类型实例的身份是他的内存地址，与值关系不大；
2. 基本数据类型始终是**有值**的；包装类型可以是`null`；
3. 基本数据类型不能用作泛型；包装类型可以；
4. 基本数据类型时、空效率更好。

下面代码中，使用包装类型时，在执行第6行时需要频繁地进行自动拆装箱，需要花费较多时间。
:::: code-group
::: code-group-item 使用基本数据类型（0.5s左右）
```Java
public class Boxing {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        long sum = 0L;
        for(int i=0; i < Integer.MAX_VALUE; i++) {
            sum+=i;
        }
        System.out.println(System.currentTimeMillis() - start);
    }
}
```
:::
::: code-group-item 使用包装类型，需要自动拆装（6s左右）
```Java
public class Boxing {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        Long sum = 0L;
        for(int i=0; i < Integer.MAX_VALUE; i++) {
            sum+=i;
        }
        System.out.println(System.currentTimeMillis() - start);
    }
}
```
:::
::::

### 选择依据
存在以下情况时，选用包装类型，否则使用基础数据类型。
1. `null`值是可接受的或者可能出现的；
2. 泛型类型必须是包装类型。

### 包装类型的缓存机制



## 泛型编程
使用泛型编程主要是两个目的：**代码重用**和**类型安全**。
### 代码重用
很好理解，当我编写一个类或者方法时，需要对多种类型数据进行相同的操作，实际上没必要为每种输入参数类型重载一个方法。

要注意，使用泛型定义的两个类型会因为泛型类型的不同而不同，如下代码11行所示：
:::: code-group
::: code-group-item 泛型示例
```Java
public class Generic<T> {
    private T obj;
    public Generic(T obj) {this.obj = obj;}

    public static void main(String[] args) {
        Generic<Integer> integerGeneric = new Generic<>(1);
        Generic<String> stringGeneric = new Generic<>("1");
        System.out.println(integerGeneric instanceof Generic); // true
        System.out.println(stringGeneric instanceof Generic); // true
        System.out.println(stringGeneric.getClass() == integerGeneric.getClass()); // true
        integerGeneric = stringGeneric; // 赋值操作会导致编译错误
    }
}
```
:::
::::

### 类型安全
使用泛型可以帮助我们在**编译时期**而非**运行时期**发现类型不一致的问题。例如我们定义了一个**ArrayList**，希望用其存储一些数字，但未指定泛型类型。此时编译器允许我们往容器中可以添加任意类型的数据而不会报错，那么当我们错误地添加了其他类型数据例如字符串等时，就会造成运行时错误。而使用泛型便能**将该错误提前到编译时期**。

另外，如第9行所示，使用泛型后，我们无需再手动指定类型转换方式。
:::: code-group
::: code-group-item 不使用泛型
```Java
public class Generic {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(1);
        list.add(2);
        list.add("3"); // 编译器不会报错
        int sum = 0;
        for (Object i : list) {
            sum += (Integer) i; // 在第三次循环会抛异常
        }
        System.out.println(sum);
    }
}
```
:::
::: code-group-item 使用泛型
```Java
public class Generic {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add("3"); // 编译器直接报错
        int sum = 0;
        for (Integer i : list) {
            sum += i;
        }
        System.out.println(sum);
    }
}
```
:::
::::